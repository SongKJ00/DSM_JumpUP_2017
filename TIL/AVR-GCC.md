##  1. AVR-GCC 컴파일러
* Linux에서 사용되던 gcc 컴파일러를 AVR 용으로 포팅하여 개발한 컴파일러
    * WINAVR : Windows 개발자들을 위한 Windows 환경으로 변형된 AVR-ㅁ

### 1-1. AVR-GCC의 장점
* 무료로 제공된다.
* 예제 소스가 많다.
    * 국내 많은 개발자들이 AVR-GCC로 개발하고 있어 예제 소스를 많이 발견할 수 있다.
* 관련 서적이 많다.

### 1-2. AVR-GCC의 단점
* 물어볼 곳이 마땅하지 않다.
    * 돈을 지불하고 사용하는 컴파일러(IAR 사의 EWAVR)들은 본사에서 기술 지원을 각종 연락을 통해 해주고 있지만, AVR-GCC는 무료이므로 물오볼 곳이 인터넷 카페 외에는 없다.  


* 다른 프로세서와의 호환성이 부족하다.
    * AVR-GCC에서는 SREG 레지스터의 I비트를 셋하는 sei() 함수와 클리어하는 cli()함수를 제공하지만, 이는 다른 프로세스의 인터럽트 허용 비트를 제어에 호환이 되지 않는다.
    * 한편, IAR 사의 EWAVR 컴파일러는 **__enable_interrupt()**, **__disable_interrupt()** 등과 같은 범용적인 함수를 제공한다. 이는 40여 개 이상의 CPU core 종류에 모두 사용할 수 있다고 한다.


* IDE 환경이 불편하다.
    * Linux 환경은 대부분의 처리가 쉘 프롬프트 상의 명령어로 실행되므로, AVR-GCC, WINAVR 모두 프롬프트 상에서 실행시켜줘야 되는 불편함이 있다.


## volatile
### 기존 메모리 할당 방식
* 일반적으로 컴파일러들은 변수들을 빠른 실행을 위해 자동적으로 레지스터 변수로 변환하여 컴파일한다.
    * 이러한 방식들은 일반적인 응용 소프트웨어인 경우에는 문제가 되지 않지만, 임베디드 소프트웨어는 문제가 될 수 있다.


* 프로그램 실행 시마다 변수가 할당되는 주소가 매번 바뀐다.
    * 인터럽트 서비스 루틴 내에 사용된 전역 변수의 할당 주소값이 실행 시마다 매번 바뀐다면 해당 데이터를 일관적으로 관리할 수가 없다.  
    * 하드웨어적으로 고정된 값들은 언제나 일정하게 유지되어야 한다.

### volatile의 필요성
* 기존 메모리 할당 방식에 의해 ISR(인터럽트 서비스 루틴) 내에 사용된 전역 변수들은 레지스터가 아닌 독립적일 수 있는 별도의 메모리 영역으로 할당 될 수 있도록 volatile이란 키워드를 붙여야 한다.

### volatile의 문제점
* 메모리 효율성이 떨어진다.
    * volatile로 선언된 메모리 영역은 독립 공간을 할당받으므로 그만큼 다른 태스크들이 할당될 메모리 공간이 줄어든다.
